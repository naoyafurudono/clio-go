package main

import (
	"fmt"
	"os"
	"path"
	"path/filepath"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

const (
	ioPackage = protogen.GoImportPath("io")
	contextPackage = protogen.GoImportPath("context")
	cobraPackage   = protogen.GoImportPath("github.com/spf13/cobra")
	clioPackage    = protogen.GoImportPath("github.com/naoyafurudono/clio-go")

	usage   = `todo`
	version = "0.0.1"
)

var genConnectPackage protogen.GoImportPath

func main() {
	if len(os.Args) == 2 && os.Args[1] == "--version" {
		fmt.Fprintln(os.Stdout, version)
		os.Exit(0)
	}
	if len(os.Args) == 2 && (os.Args[1] == "-h" || os.Args[1] == "--help") {
		fmt.Fprintln(os.Stdout, usage)
		os.Exit(0)
	}
	if len(os.Args) != 1 {
		fmt.Fprintln(os.Stderr, usage)
		os.Exit(1)
	}
	protogen.Options{}.Run(
		func(plugin *protogen.Plugin) error {
			for _, file := range plugin.Files {
				if file.Generate {
					generate(plugin, file)
				}
			}
			return nil
		},
	)
}

func generate(plugin *protogen.Plugin, f *protogen.File) {
	generatedFilenamePrefixToSlash := filepath.ToSlash(f.GeneratedFilenamePrefix)
	filepath := path.Join(
		path.Dir(generatedFilenamePrefixToSlash),
		string(f.GoPackageName)+"clio",
		path.Base(generatedFilenamePrefixToSlash)+".clio.go",
	)
	connectPath := path.Join(string(f.GoImportPath), string(f.GoPackageName)+"connect")
	genConnectPackage = protogen.GoImportPath(connectPath)
	gf := plugin.NewGeneratedFile(filepath, f.GoImportPath)

	generatePreamble(gf, f)
	generateBody(gf, f)
}

func generatePreamble(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by protoc-gen-clio-go. DO NOT EDIT.")
	g.P("//")
	if file.Proto.GetOptions().GetDeprecated() {
		g.P(file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// Source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName+"clio")
	g.P()
}

func generateBody(g *protogen.GeneratedFile, f *protogen.File) {
	for _, service := range f.Services {
		sig := cmdSignature(g, service.GoName)
		g.P(sig, " {")

		serviceCommandName := strings.ToLower(service.GoName)
		generateCobraCommand(g, serviceCommandName, strLit(serviceCommandName), cts(service.Comments.Leading.String()), cts(service.Comments.Leading.String()))
		g.P(fmt.Sprintf(`var reqData *string = %s.PersistentFlags().StringP("data", "d", "{}", "request message represented as a JSON")`, serviceCommandName))

		var children = make([]string, 0, len(service.Methods))
		for _, method := range service.Methods {
			rpcName := strings.ToLower(method.GoName)
			generateClioCommand(g, rpcName, method.GoName, strLit(rpcName), cts(method.Comments.Leading.String()), cts(method.Comments.Leading.String()))
			children = append(children, rpcName)
		}
		generateAddCommand(g, serviceCommandName, children)
		g.P("return &" + serviceCommandName)
		g.P("}")
	}
}

func cmdSignature(g *protogen.GeneratedFile, serviceName string) string {
	cmdName := fmt.Sprintf("New%sCommand", serviceName)
	// XXX: depends on connect implementation
	// see https://github.com/connectrpc/connect-go/blob/d55ebd843cc062404c2171354ddfe96da0346e4b/cmd/protoc-gen-connect-go/main.go#L637
	connectServerName := fmt.Sprintf("%sHandler", serviceName)
	return fmt.Sprintf("func %s(ctx %s, s %s, w %s) *%s",
		cmdName, // function name
		g.QualifiedGoIdent(contextPackage.Ident("Context")),            // first param type
		g.QualifiedGoIdent(genConnectPackage.Ident(connectServerName)), // second param type
		g.QualifiedGoIdent(ioPackage.Ident("Writer")),
		g.QualifiedGoIdent(cobraPackage.Ident("Command")),
	)
}

func generateCobraCommand(g *protogen.GeneratedFile, varName, use, short, long string) {
	g.P("var "+varName+"=", g.QualifiedGoIdent(cobraPackage.Ident("Command"))+"{")
	g.P("Use: " + use + ",")
	g.P("Long: " + long + ",")
	g.P("Short: ", short+",")
	g.P("}")
}

func generateClioCommand(g *protogen.GeneratedFile, varName, methodName, use, short, long string) {
	g.P("var "+varName+"=", g.QualifiedGoIdent(clioPackage.Ident("RpcCommand"))+"(ctx,")
	g.P("s." + methodName + ",")
	g.P(use + ",")
	g.P(long + ",")
	g.P(short + ",")
	g.P("reqData,")
	g.P("w,")
	g.P(")")
}

func generateAddCommand(g *protogen.GeneratedFile, parentCommandName string, children []string) {
	g.P(parentCommandName + ".AddCommand(")
	for _, child := range children {
		g.P(child + ",")
	}
	g.P(")")
}


// comment to string
func cts(c string) string {
	return fmt.Sprintf(`"%s"`, strings.Trim(c, " /\n"))
}

func strLit(s string) string {
	return fmt.Sprintf(`"%s"`, s)
}
